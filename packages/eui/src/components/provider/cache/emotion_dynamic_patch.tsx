/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import { EmotionCache } from '@emotion/react';

/**
 * Applies a monkey patch to the given Emotion cache to flag dynamic styles.
 * This is modular and can be reused in other places.
 */
export function patchCacheForDynamicStyles(cache: EmotionCache) {
  if (!cache || typeof cache !== 'object' || (cache as any).__patched) return;

  const baseClassMap = new Map<string, Set<string>>();

  /**
   * A utility to normalize selectors by removing the dynamic part
   * of the class name generated by Emotion.
   */
  function getBaseClass(selector: string): string | null {
    const match = selector.match(/\.css-[a-zA-Z0-9]+-(.+)/);
    return match ? match[1] : null;
  }

  /**
   * Checks for dynamic styles by tracking hashes for each base class.
   * If multiple hashes are seen for the same base class, a warning is logged.
   * Returns true if a dynamic style was flagged.
   */
  function flagDynamicStyles(selector: string, serialized: any): boolean {
    const baseClass = getBaseClass(selector);

    if (baseClass) {
      const hashes = baseClassMap.get(baseClass) || new Set<string>();
      const hash =
        serialized && serialized.name ? serialized.name.split('-')[0] : null;

      if (hash) {
        hashes.add(hash);
        if (hashes.size > 1) {
          console.warn(
            `[EuiCacheProvider] Dynamic style detected for base selector: ${baseClass}. ` +
              'This usually means you are passing dynamic values to the `css` prop. ' +
              'Consider using the `style` prop for dynamic values instead.'
          );
          baseClassMap.set(baseClass, hashes);

          return true;
        }

        baseClassMap.set(baseClass, hashes);
      }
    }
    return false;
  }

  const originalInsert = cache.insert;
  cache.insert = function (selector, serialized, sheet, shouldCache) {
    flagDynamicStyles(selector, serialized);
    return originalInsert.call(this, selector, serialized, sheet, shouldCache);
  };
  (cache as any).__patched = true;
  (cache as any).__baseClassMap = baseClassMap;
}
