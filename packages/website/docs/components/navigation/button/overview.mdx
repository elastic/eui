---
slug: /navigation/button
id: navigation_button
---

# Button

EUI provides many types, colors and configurations of buttons. The one best suited for you context depends on placement, prominence, and state. For primary and secondary actions it is best to use the basic **EuiButton**. For tertiary or low prominence actions, use **EuiButtonEmpty**.

Be sure to read the full [button usage guidelines](./guidelines).

import ButtonIntro from './button_intro';

<ButtonIntro />

## Basic button

The most standard button component is **EuiButton** which comes in two styles and two sizes. The `fill` style should be reserved for the main action and limited in number for a single page. Use the small size (`size="s"`) when placing buttons into smaller containers like popovers.

When using colors other than `primary`, be sure that either the words or an icon also represents the status. For instance, don't rely on color alone to represent dangerous actions but use words like "Delete" not "Confirm". The `text` and `accent` colors should be used sparingly as they can easily be confused with other states like disabled and danger.

All button components accept an `iconType` which must be an acceptable [**EuiIcon**](/docs/display/icons) type. Multi-color icons like app icons will be converted to single color. Icons can be displayed on the opposite side by passing `iconSide="right"`.

```tsx interactive
import React, { useState } from 'react';
import {
  EuiButton,
  EuiFlexGroup,
  EuiFlexItem,
  EuiPanel,
  EuiSpacer,
  EuiSelect,
  EuiSwitch,
} from '@elastic/eui';
import { COLORS } from '@elastic/eui/es/components/button/button';

export default () => {
  const [disableButton, setDisableButton] = useState(false);
  const [fillButton, setFillButton] = useState(false);
  const [fullButton, setFullButton] = useState(false);
  const [smallButton, setSmallButton] = useState(false);
  const [withIconButton, setWithIconButton] = useState(false);
  const buttonColorsOptions = COLORS.map((name) => {
    return {
      value: name,
      text: name,
    };
  });
  
  const [buttonColor, setButtonColor] = useState(buttonColorsOptions[3].value);

  const onChangeButtonColor = (e) => {
    setButtonColor(e.target.value);
  };

  return(
    <div>
    <EuiFlexGroup
        gutterSize="m"
        alignItems="center"
        wrap={true}
      >
        <EuiFlexItem grow={false}>
          <EuiSelect
            prepend="Color"
            options={buttonColorsOptions}
            value={buttonColor}
            onChange={(e) => onChangeButtonColor(e)}
            compressed
            aria-label="Button colors"
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSwitch
            compressed
            label="Fill"
            checked={fillButton}
            onChange={() => setFillButton(!fillButton)}
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSwitch
            compressed
            label="Full width"
            checked={fullButton}
            onChange={() => setFullButton(!fullButton)}
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSwitch
            compressed
            label="Small"
            checked={smallButton}
            onChange={() => setSmallButton(!smallButton)}
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSwitch
            compressed
            label="With icon"
            checked={withIconButton}
            onChange={() => setWithIconButton(!withIconButton)}
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSwitch
            compressed
            label="Disabled"
            checked={disableButton}
            onChange={() => setDisableButton(!disableButton)}
          />
        </EuiFlexItem>
      </EuiFlexGroup>
      <EuiSpacer />
      <EuiPanel className='plain' hasBorder css={{width: 400, maxWidth: '100%'}}>
        <EuiButton
          color={buttonColor}
          disabled={disableButton}
          fill={fillButton}
          fullWidth={fullButton}
          size={smallButton ? 's' : 'm'}
          iconType={withIconButton ? 'discoverApp' : null}
          onClick={() => {}}
        >
          {!withIconButton ? 'Button' : 'Open in Discover'}
        </EuiButton>
      </EuiPanel>
    </div>
  );
};
```

## Empty button

Use **EuiButtonEmpty** when you want to reduce the importance of the button, but still want to align it to the rest of the buttons. It is also the only button component that supports down to size `xs`.

```tsx interactive
import React from 'react';

import {
  EuiButtonEmpty,
  EuiFlexGroup,
  EuiFlexItem,
} from '@elastic/eui';

export default () => (
  <EuiFlexGroup
    wrap={true}
    gutterSize="s"
    alignItems="center"
  >
    <EuiFlexItem grow={false}>
      <EuiButtonEmpty
        onClick={() => {}}
      >
        Empty button
      </EuiButtonEmpty>
    </EuiFlexItem>

    <EuiFlexItem grow={false}>
      <EuiButtonEmpty
        size="s"
        onClick={() => {}}
      >
        Small empty button
      </EuiButtonEmpty>
    </EuiFlexItem>

    <EuiFlexItem grow={false}>
      <EuiButtonEmpty
        size="xs"
        onClick={() => {}}
      >
        Extra small empty button
      </EuiButtonEmpty>
    </EuiFlexItem>
  </EuiFlexGroup>
);
```

### Flush empthy button

By default, buttons contain padding. Apply the `flush` property in cases where precise alignment and spacing is desired. This situation can arise when **EuiButtonEmpty** appears within a horizontal list of buttons such as a menu.

```tsx interactive
import React from 'react';

import {
  EuiButton,
  EuiButtonEmpty,
  EuiFlexGroup,
  EuiFlexItem,
  EuiHorizontalRule,
  EuiPanel,
  EuiTitle,
} from '@elastic/eui';

export default () => (
  <EuiFlexGroup gutterSize="m" direction="row">
    <EuiFlexItem css={{width: 240}} grow={false}>
      <EuiPanel color="plain" hasBorder>
        <EuiTitle size="xs"><h4>Title of panel</h4></EuiTitle>
        <EuiHorizontalRule />
        <EuiButtonEmpty flush="left">Flush left</EuiButtonEmpty>
      </EuiPanel>
    </EuiFlexItem>
    <EuiFlexItem css={{width: 240}} grow={false}>
      <EuiPanel css={{textAlign: "right"}} color="plain" hasBorder grow={false}>
        <EuiButton size="s">Button</EuiButton>
        <EuiHorizontalRule />
        <EuiButtonEmpty flush="right">Flush right</EuiButtonEmpty>
      </EuiPanel>
    </EuiFlexItem>
</EuiFlexGroup>
);
```

## Icon button

An **EuiButtonIcon** is a button that only contains an icon (no text). Use the `display` and `size` props to match the appearance of your **EuiButtonIcon** to other standard buttons. By default they will appear as `xs`, `empty` buttons.

:::note Accessibility recommendation
**EuiButtonIcon** requires an `aria-label` to express the meaning to screen readers.
:::

```tsx interactive
import React, { useState } from 'react';

import {
  EuiButtonIcon,
  EuiFlexGroup,
  EuiFlexItem,
  EuiPanel,
  EuiSelect,
  EuiSpacer,
  EuiSwitch,
  EuiTitle,
} from '@elastic/eui';
import { COLORS } from '@elastic/eui/es/components/button/button';

const DISPLAY_TYPES = ['empty', 'base', 'fill'];
const DISPLAY_SIZES = ['xs', 's', 'm'];
const ICON_SIZES = ['s', 'm', 'l', 'xl', 'xxl', 'original'];

export default () => {
  const buttonColorsOptions = COLORS.map((name) => {
    return {
      value: name,
      text: name,
    };
  });
  const displayTypeOptions = DISPLAY_TYPES.map((name) => {
    return {
      value: name,
      text: name,
    };
  });
  const displaySizeOptions = DISPLAY_SIZES.map((name) => {
    return {
      value: name,
      text: name,
    };
  });
  const iconSizeOptions = ICON_SIZES.map((name) => {
    return {
      value: name,
      text: name,
    };
  });
  const [disableButton, setDisableButton] = useState(false);
  const [displayType, setDisplayType] = useState(displayTypeOptions[0].value);
  const [displaySize, setDisplaySize] = useState(displaySizeOptions[0].value);
  const [iconSize, setIconSize] = useState(iconSizeOptions[1].value);
  const [buttonColor, setButtonColor] = useState(buttonColorsOptions[3].value);

  const onChangeDisplayType = (e) => {
    setDisplayType(e.target.value);
  };

  const onChangeDisplaySize = (e) => {
    setDisplaySize(e.target.value);
  };

  const onChangeIconSize = (e) => {
    setIconSize(e.target.value);
  };

  const onChangeButtonColor = (e) => {
    setButtonColor(e.target.value);
  };

  return(
    <>
      <EuiFlexGroup
        gutterSize="m"
        alignItems="center"
        wrap={true}
      >
        <EuiFlexItem grow={false}>
          <EuiSelect
            prepend="Color"
            options={buttonColorsOptions}
            value={buttonColor}
            onChange={(e) => onChangeButtonColor(e)}
            compressed
            aria-label="Button colors"
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSelect
            prepend="Display"
            options={displayTypeOptions}
            value={displayType}
            onChange={(e) => onChangeDisplayType(e)}
            compressed
            aria-label="Button display styles"
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSelect
            prepend="Size"
            options={displaySizeOptions}
            value={displaySize}
            onChange={(e) => onChangeDisplaySize(e)}
            compressed
            aria-label="Button sizes"
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSelect
            prepend="Icon size"
            options={iconSizeOptions}
            value={iconSize}
            onChange={(e) => onChangeIconSize(e)}
            compressed
            aria-label="Icon in button sizes"
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSwitch
            compressed
            label="Disabled"
            checked={disableButton}
            onChange={() => setDisableButton(!disableButton)}
          />
        </EuiFlexItem>
      </EuiFlexGroup>
      <EuiSpacer />
      <EuiTitle size="xxs">
        <h3>Icon button</h3>
      </EuiTitle>
      <EuiSpacer size="s" />
        <EuiButtonIcon
          color={buttonColor}
          display={displayType}
          size={displaySize}
          iconSize={iconSize}
          disabled={disableButton}
          onClick={() => {}}
          iconType="documentation"
          aria-label="Open documentation"
        />
      <EuiSpacer />
      <EuiPanel type="plain" hasBorder css={{display: 'inline-block'}}>
        <EuiTitle size="xxxs">
          <h4>Icons inherit button color</h4>
        </EuiTitle>
        <EuiSpacer size="s" />
        <EuiFlexGroup responsive={false} gutterSize="s" alignItems="flexStart">          
          <EuiFlexItem grow={false}>
            <EuiButtonIcon display="base" iconType="lensApp" size="m" aria-label="Lens" />
          </EuiFlexItem>
          <EuiFlexItem grow={false}>
            <EuiButtonIcon display="base" iconType="warning" size="s" color="warning" aria-label="Warning" />
          </EuiFlexItem>
          <EuiFlexItem grow={false}>
            <EuiButtonIcon
              iconType="dashboardApp"
              aria-label="Dashboard"
              color="text"
            />
          </EuiFlexItem>
          <EuiFlexItem grow={false}>
            <EuiButtonIcon
              iconType="trash"
              aria-label="Delete"
              color="danger"
            />
          </EuiFlexItem>
        </EuiFlexGroup>
      </EuiPanel>
    </>
  );
};

```

## Button group

An **EuiButtonGroup** is for indicating _selection only_. They utilize the `type="single"` or `"multi"` prop to determine whether multiple or only single selections are allowed per group.

:::note Accessibility recommendation
In order for groups to be properly read as groups with a title, the `legend` prop is **required**. This is only for accessibility, however, so it will be visibly hidden.
:::

```tsx interactive
import React, { useState, Fragment } from 'react';

import {
  EuiButtonGroup,
  EuiFlexGroup,
  EuiFlexItem,
  EuiPanel,
  EuiSpacer,
  EuiSwitch,
  EuiTitle,
  useGeneratedHtmlId
} from '@elastic/eui';

export default () => {
  const [disableButton, setDisableButton] = useState(false);
  const [fullButton, setFullButton] = useState(false);

  const basicButtonGroupPrefix = useGeneratedHtmlId({
    prefix: 'basicButtonGroup',
  });
  const multiSelectButtonGroupPrefix = useGeneratedHtmlId({
    prefix: 'multiSelectButtonGroup',
  });
  const disabledButtonGroupPrefix = useGeneratedHtmlId({
    prefix: 'disabledButtonGroup',
  });

  const toggleButtons = [
    {
      id: `${basicButtonGroupPrefix}__0`,
      label: 'Option one',
    },
    {
      id: `${basicButtonGroupPrefix}__1`,
      label: 'Option two is selected by default',
    },
    {
      id: `${basicButtonGroupPrefix}__2`,
      label: 'Option three',
    },
  ];

  const toggleButtonsDisabled = [
    {
      id: `${disabledButtonGroupPrefix}__0`,
      label: 'Option one',
    },
    {
      id: `${disabledButtonGroupPrefix}__1`,
      label: 'Option two is selected by default',
    },
    {
      id: `${disabledButtonGroupPrefix}__2`,
      label: 'Option three',
    },
  ];

  const toggleButtonsMulti = [
    {
      id: `${multiSelectButtonGroupPrefix}__0`,
      label: 'Option 1',
    },
    {
      id: `${multiSelectButtonGroupPrefix}__1`,
      label: 'Option 2 is selected by default',
    },
    {
      id: `${multiSelectButtonGroupPrefix}__2`,
      label: 'Option 3',
    },
  ];

  const [toggleIdSelected, setToggleIdSelected] = useState(
    `${basicButtonGroupPrefix}__1`
  );
  const [toggleIdDisabled, setToggleIdDisabled] = useState(
    `${disabledButtonGroupPrefix}__1`
  );
  const [toggleIdToSelectedMap, setToggleIdToSelectedMap] = useState({
    [`${multiSelectButtonGroupPrefix}__1`]: true,
  });

  const onChange = (optionId) => {
    setToggleIdSelected(optionId);
  };

  const onChangeDisabled = (optionId) => {
    setToggleIdDisabled(optionId);
  };

  const onChangeMulti = (optionId) => {
    const newToggleIdToSelectedMap = {
      ...toggleIdToSelectedMap,
      ...{
        [optionId]: !toggleIdToSelectedMap[optionId],
      },
    };
    setToggleIdToSelectedMap(newToggleIdToSelectedMap);
  };

  return (
    <Fragment>
      <EuiFlexGroup
        gutterSize="m"
        alignItems="center"
      >
        <EuiFlexItem grow={false}>
          <EuiSwitch
            compressed
            label="Full width"
            checked={fullButton}
            onChange={() => setFullButton(!fullButton)}
          />
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiSwitch
            compressed
            label="Disabled"
            checked={disableButton}
            onChange={() => setDisableButton(!disableButton)}
          />
        </EuiFlexItem>
      </EuiFlexGroup>
      <EuiSpacer />
      <EuiPanel type="plain" hasBorder css={{width: 600, maxWidth: '100%'}}>
        <EuiTitle size="xxs">
          <h3>Default</h3>
        </EuiTitle>
        <EuiSpacer size="s" />
        <EuiButtonGroup
          legend="Default single select button group"
          isFullWidth={fullButton}
          isDisabled={disableButton}
          options={toggleButtons}
          idSelected={toggleIdSelected}
          onChange={(id) => onChange(id)}
        />
        <EuiSpacer />
        <EuiTitle size="xxs">
          <h3>Primary color with multi select</h3>
        </EuiTitle>
        <EuiSpacer size="s" />
        <EuiButtonGroup
          legend="Primary color multi select button group"
          isFullWidth={fullButton}
          isDisabled={disableButton}
          options={toggleButtonsMulti}
          idToSelectedMap={toggleIdToSelectedMap}
          onChange={(id) => onChangeMulti(id)}
          color="primary"
          type="multi"
        />
      </EuiPanel>
    </Fragment>
  );
};
```

### Icon only button group

Use the `isIconOnly` prop when displaying a group of icon-only buttons.

```tsx interactive
import React, { useState, Fragment } from 'react';

import { EuiButtonGroup, htmlIdGenerator } from '@elastic/eui';

const idPrefix3 = htmlIdGenerator()();

export default () => {
  const toggleButtonsIcons = [
    {
      id: `${idPrefix3}0`,
      label: 'Align left',
      iconType: 'editorAlignLeft',
    },
    {
      id: `${idPrefix3}1`,
      label: 'Align center',
      iconType: 'editorAlignCenter',
    },
    {
      id: `${idPrefix3}2`,
      label: 'Align right',
      iconType: 'editorAlignRight',
      isDisabled: true,
    },
  ];

  const toggleButtonsIconsMulti = [
    {
      id: `${idPrefix3}3`,
      label: 'Bold',
      name: 'bold',
      iconType: 'editorBold',
    },
    {
      id: `${idPrefix3}4`,
      label: 'Italic',
      name: 'italic',
      iconType: 'editorItalic',
      isDisabled: true,
    },
    {
      id: `${idPrefix3}5`,
      label: 'Underline',
      name: 'underline',
      iconType: 'editorUnderline',
    },
    {
      id: `${idPrefix3}6`,
      label: 'Strikethrough',
      name: 'strikethrough',
      iconType: 'editorStrike',
    },
  ];

  const [toggleIconIdSelected, setToggleIconIdSelected] = useState(
    `${idPrefix3}1`
  );
  const [toggleIconIdToSelectedMap, setToggleIconIdToSelectedMap] = useState(
    {}
  );

  const onChangeIcons = (optionId) => {
    setToggleIconIdSelected(optionId);
  };

  const onChangeIconsMulti = (optionId) => {
    const newToggleIconIdToSelectedMap = {
      ...toggleIconIdToSelectedMap,
      ...{
        [optionId]: !toggleIconIdToSelectedMap[optionId],
      },
    };

    setToggleIconIdToSelectedMap(newToggleIconIdToSelectedMap);
  };

  return (
    <Fragment>
      <EuiButtonGroup
        legend="Text align"
        options={toggleButtonsIcons}
        idSelected={toggleIconIdSelected}
        onChange={(id) => onChangeIcons(id)}
        isIconOnly
      />
      &nbsp;&nbsp;
      <EuiButtonGroup
        legend="Text style"
        options={toggleButtonsIconsMulti}
        idToSelectedMap={toggleIconIdToSelectedMap}
        onChange={(id) => onChangeIconsMulti(id)}
        type="multi"
        isIconOnly
      />
    </Fragment>
  );
};
```

### Button group tooltips

Buttons within a button group will automatically display a default browser tooltip containing the button `label` text. This can be customized or unset via the `title` property in your `options` button configuration.

To instead display an **EuiToolTip** around your button(s), pass the `toolTipContent` property. You can also use `toolTipProps` to customize tooltip placement, title, and any other prop that [**EuiToolTip**](/docs/display/tooltip) accepts.

```tsx interactive
import React, { useState } from 'react';

import { EuiButtonGroup } from '@elastic/eui';

export default () => {
  const toggleButtons = [
    {
      id: 'buttonGroup__0',
      label: 'Default title',
    },
    {
      id: 'buttonGroup__1',
      label: 'Custom tooltip content',
      toolTipContent: 'This is a custom tooltip',
    },
    {
      id: 'buttonGroup__2',
      label: 'Custom tooltip props',
      toolTipContent: 'This is another custom tooltip',
      toolTipProps: {
        title: 'My custom title',
        position: 'right',
      },
    },
  ];

  const [toggleIdSelected, setToggleIdSelected] = useState('buttonGroup__1');

  const onChange = (optionId) => {
    setToggleIdSelected(optionId);
  };

  return (
    <EuiButtonGroup
      legend="This is a group with tooltips"
      options={toggleButtons}
      idSelected={toggleIdSelected}
      onChange={(id) => onChange(id)}
    />
  );
};
```

### Button group in forms

<Badge>Pattern</Badge>

When using button groups within compressed forms, match the form elements by adding `buttonSize="compressed"`. Compressed groups should always be `fullWidth` so they line up nicely in their small container unless they are icon only.

For a more detailed example of how to integrate with forms, see the ["Complex example"](/docs/forms/layouts/compressed-forms/#complex-example) on the compressed forms page.

```tsx interactive
import React, { useState } from 'react';

import {
  EuiButtonGroup,
  EuiSpacer,
  EuiPanel,
  useGeneratedHtmlId,
} from '@elastic/eui';

export default () => {
  const compressedToggleButtonGroupPrefix = useGeneratedHtmlId({
    prefix: 'compressedToggleButtonGroup',
  });
  const multiSelectButtonGroupPrefix = useGeneratedHtmlId({
    prefix: 'multiSelectButtonGroup',
  });

  const toggleButtonsCompressed = [
    {
      id: `${compressedToggleButtonGroupPrefix}__0`,
      label: 'fine',
    },
    {
      id: `${compressedToggleButtonGroupPrefix}__1`,
      label: 'rough',
    },
    {
      id: `${compressedToggleButtonGroupPrefix}__2`,
      label: 'coarse',
    },
  ];

  const toggleButtonsIconsMulti = [
    {
      id: `${multiSelectButtonGroupPrefix}__0`,
      label: 'Bold',
      name: 'bold',
      iconType: 'editorBold',
    },
    {
      id: `${multiSelectButtonGroupPrefix}__1`,
      label: 'Italic',
      name: 'italic',
      iconType: 'editorItalic',
      isDisabled: true,
    },
    {
      id: `${multiSelectButtonGroupPrefix}__2`,
      label: 'Underline',
      name: 'underline',
      iconType: 'editorUnderline',
    },
    {
      id: `${multiSelectButtonGroupPrefix}__3`,
      label: 'Strikethrough',
      name: 'strikethrough',
      iconType: 'editorStrike',
    },
  ];

  const [toggleIconIdToSelectedMapIcon, setToggleIconIdToSelectedMapIcon] =
    useState({});
  const [toggleCompressedIdSelected, setToggleCompressedIdSelected] = useState(
    `${compressedToggleButtonGroupPrefix}__1`
  );

  const onChangeCompressed = (optionId) => {
    setToggleCompressedIdSelected(optionId);
  };

  const onChangeIconsMultiIcons = (optionId) => {
    const newToggleIconIdToSelectedMapIcon = {
      ...toggleIconIdToSelectedMapIcon,
      ...{
        [optionId]: !toggleIconIdToSelectedMapIcon[optionId],
      },
    };

    setToggleIconIdToSelectedMapIcon(newToggleIconIdToSelectedMapIcon);
  };

  return (
    <EuiPanel hasBorder style={{ maxWidth: 300 }}>
      <EuiButtonGroup
        name="coarsness"
        legend="This is a basic group"
        options={toggleButtonsCompressed}
        idSelected={toggleCompressedIdSelected}
        onChange={(id) => onChangeCompressed(id)}
        buttonSize="compressed"
        isFullWidth
      />
      <EuiSpacer />
      <EuiButtonGroup
        legend="Text style"
        className="eui-displayInlineBlock"
        options={toggleButtonsIconsMulti}
        idToSelectedMap={toggleIconIdToSelectedMapIcon}
        onChange={(id) => onChangeIconsMultiIcons(id)}
        type="multi"
        buttonSize="compressed"
        isIconOnly
      />
    </EuiPanel>
  );
};
```

## Split button

<Badge>Pattern</Badge>

EUI [does not support](https://github.com/elastic/eui/issues/4171) split buttons specifically. Instead, use separate buttons for the main and overflow actions. This pattern is achieved by setting the `display` and `size` props on **EuiButtonIcon** to match that of the primary button.

```tsx interactive
import React, { useState } from 'react';

import {
  EuiButton,
  EuiButtonIcon,
  EuiFlexGroup,
  EuiFlexItem,
  EuiContextMenuPanel,
  EuiContextMenuItem,
  EuiPopover,
  useGeneratedHtmlId,
} from '@elastic/eui';

export default () => {
  const [isPopoverOpen, setPopover] = useState(false);
  const splitButtonPopoverId = useGeneratedHtmlId({
    prefix: 'splitButtonPopover',
  });

  const onButtonClick = () => {
    setPopover(!isPopoverOpen);
  };

  const closePopover = () => {
    setPopover(false);
  };

  const items = [
    <EuiContextMenuItem key="copy" icon="copy" onClick={closePopover}>
      Copy
    </EuiContextMenuItem>,
    <EuiContextMenuItem key="edit" icon="pencil" onClick={closePopover}>
      Edit
    </EuiContextMenuItem>,
    <EuiContextMenuItem key="share" icon="share" onClick={closePopover}>
      Share
    </EuiContextMenuItem>,
  ];

  return (
    <>
      <EuiFlexGroup responsive={false} gutterSize="xs" alignItems="center">
        <EuiFlexItem grow={false}>
          <EuiButton size="s" fill iconType="save">
            Save
          </EuiButton>
        </EuiFlexItem>
        <EuiFlexItem grow={false}>
          <EuiPopover
            id={splitButtonPopoverId}
            button={
              <EuiButtonIcon
                display="fill"
                size="s"
                iconType="boxesVertical"
                aria-label="More"
                onClick={onButtonClick}
              />
            }
            isOpen={isPopoverOpen}
            closePopover={closePopover}
            panelPaddingSize="none"
            anchorPosition="downLeft"
          >
            <EuiContextMenuPanel size="s" items={items} />
          </EuiPopover>
        </EuiFlexItem>
      </EuiFlexGroup>
    </>
  );
};
```

## Toggle button

<Badge>Pattern</Badge>

A toggle button can be built with any button including the standard **EuiButton**, **EuiButtonEmpty** , or **EuiButtonIcon**. Use state management to handle the visual differences for on and off.

Consider the followingn exception cases when building a toggle button.

1.  If your button changes its readable **text**, via children or `aria-label`, then there is no additional accessibility concern.

```tsx interactive
import React, { useState } from 'react';

import { EuiButton, EuiButtonIcon } from '@elastic/eui';

export default () => {
  const [toggle0On, setToggle0On] = useState(false);
  const [toggle1On, setToggle1On] = useState(true);

  return (
    <>
      <EuiButton
        onClick={() => {
          setToggle0On((isOn) => !isOn);
        }}
      >
        {toggle0On ? 'Toggled' : 'Toggle me'}
      </EuiButton>
      &emsp;
      <EuiButtonIcon
        title={toggle1On ? 'Play' : 'Pause'}
        aria-label={toggle1On ? 'Play' : 'Pause'}
        iconType={toggle1On ? 'play' : 'pause'}
        onClick={() => {
          setToggle1On((isOn) => !isOn);
        }}
      />
    </>
  );
};
```

2.  If your button only changes the **visual** appearance, you must add `aria-pressed` passing a boolean for the on and off states. All EUI button types provide a helper prop for this called `isSelected`.

:::note Accessibility recommendation
Do not add `aria-pressed` or `isSelected` if you also change the readable text.
:::

```tsx interactive
import React, { useState } from 'react';
import { EuiButton, EuiButtonIcon } from '@elastic/eui';

export default () => {
  const [toggle2On, setToggle2On] = useState(true);
  const [toggle3On, setToggle3On] = useState(false);

  return (
    <>
      <EuiButton
        isSelected={toggle2On}
        fill={toggle2On}
        iconType={toggle2On ? 'starFilledSpace' : 'starPlusEmpty'}
        onClick={() => {
          setToggle2On((isOn) => !isOn);
        }}
      >
        Toggle me
      </EuiButton>
      &emsp;
      <EuiButtonIcon
        display={toggle3On ? 'base' : 'empty'}
        size="m"
        aria-label="Autosave"
        title="Autosave"
        iconType="save"
        aria-pressed={toggle3On}
        color={toggle3On ? 'primary' : 'text'}
        onClick={() => {
          setToggle3On((isOn) => !isOn);
        }}
      />
    </>
  );
};
```

## Loading state

Setting the `isLoading` prop to true will add the loading spinner or swap the existing icon for the loading spinner and set the button to disabled. It is good practice to also rename the button to "Loading…".

```tsx interactive
import React, { useState } from 'react';

import {
  EuiButton,
  EuiSpacer,
  EuiSwitch,
} from '@elastic/eui';

export default () => {
  const [loadingButton, setLoadingButton] = useState(true);

  return(
    <>
      <EuiSwitch
        compressed
        label="Is loading"
        checked={loadingButton}
        onChange={() => setLoadingButton(!loadingButton)}
      />
      <EuiSpacer />
      <EuiButton isLoading={loadingButton} fill>
        {loadingButton ? 'Loading...' : 'Button'}
      </EuiButton>
    </>
  );
};
```

## Using href and onClick

Every button component accepts either an `href` (rendered as an `<a>`) or an `onClick` (rendered as a `<button>`). While they also accept both props to be applied simultaneously to support certain routing mechansims, it is not usually recommended. For more specific information on how to integrate EUI buttons with react-router, [see this wiki page](https://github.com/elastic/eui/blob/main/wiki/consuming-eui/react-router.md#how-react-router-works).

If you are creating a purely text-based link, like the one in the previous paragraph, use [**EuiLink**](../link) instead.

```tsx interactive
import React, { Fragment } from 'react';

import {
  EuiButton,
  EuiButtonEmpty,
  EuiButtonIcon,
  EuiFlexGroup,
  EuiFlexItem,
  EuiSpacer,
} from '@elastic/eui';

export default () => (
  <Fragment>
    <EuiFlexGroup responsive={false} wrap gutterSize="s" alignItems="center">
      <EuiFlexItem grow={false}>
        <EuiButton href="#using-href-and-onclick">Button with href</EuiButton>
      </EuiFlexItem>

      <EuiFlexItem grow={false}>
        <EuiButtonEmpty href="#using-href-and-onclick">
          Empty button with href
        </EuiButtonEmpty>
      </EuiFlexItem>
    </EuiFlexGroup>
  </Fragment>
);
```

## Props

import docgen from '@elastic/eui-docgen/dist/components/button';

<PropTable definition={docgen.EuiButton} />
