// Pointer events and interactions are handled by the input (checkbox/radio)
// and not the button, this mixin helps to target that element for states
@mixin euiButtonToggleStates(){
  @at-root {
    .euiButtonToggle__input:enabled:hover + #{&},
    .euiButtonToggle__input:enabled:focus + #{&},
    .euiButtonToggle__input:enabled:active + #{&} {
      @content;
    }
  }
}

.euiButtonToggle__wrapper {
  display: inline-block;
}

.euiButtonToggle {
  // always the same border color unless it's selected
  border-color: $euiButtonToggleBorderColor;

  &:enabled {
    @include euiSlightShadow; // don't colorize the shadow
  }

  .euiButtonToggle__content {
    padding: 0 $euiSizeS;
  }

  @include euiButtonToggleStates() {
    @include euiSlightShadowHover;
    text-decoration: underline;
  }

  &:disabled {
    border-color: $euiButtonToggleBorderColor;
  }
}

// Modifier naming and colors.
$buttonTypes: (
  primary: $euiColorPrimary,
  secondary: $euiColorSecondary,
  warning: $euiColorWarning,
  danger: $euiColorDanger,
  ghost: $euiColorGhost, // Ghost is special, and does not care about theming.
  text: $euiColorDarkShade, // Reserved for special use cases
);

// Create button modifiders based upon the map.
@each $name, $color in $buttonTypes {
  .euiButtonToggle[class*="#{$name}"] {
    @include euiButtonToggleStates() {
      background-color: transparentize($color, .9);
    }

    &[class*="fill"] {
      @include euiButtonToggleStates() {
        background-color: darken($color, 5%);
        border-color: darken($color, 5%);
      }
    }
  }
}
