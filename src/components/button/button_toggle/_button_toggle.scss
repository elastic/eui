// Pointer events and interactions are handled by the input (checkbox/radio)
// and not the button, this mixin helps to target that element for states
@mixin euiButtonToggleStates(){
  @at-root {
    .euiButtonToggle__input:enabled:hover + #{&},
    .euiButtonToggle__input:enabled:focus + #{&},
    .euiButtonToggle__input:enabled:active + #{&} {
      @content;
    }
  }
}

.euiButtonToggle__wrapper {
  display: inline-block;
}

.euiButtonToggle {
  // always the same border color unless it's selected
  border-color: $euiButtonToggleBorderColor;

  &:enabled {
    @include euiSlightShadow; // don't colorize the shadow
  }

  .euiButtonToggle__content {
    padding: 0 $euiSizeS;
  }

  @include euiButtonToggleStates() {
    @include euiSlightShadowHover;
    text-decoration: underline;
  }

  &:disabled {
    border-color: $euiButtonToggleBorderColor;
  }
}

// // Default color
// .euiButtonToggle:not([class*="primary"]):not([class*="ghost"]) {
//   @include euiButtonToggleStates() {
//     background-color: transparentize($euiColorDarkShade, .9);
//   }

//   &[class*="--fill"] {
//     background-color: $euiColorDarkShade;
//     border-color: $euiColorDarkShade;
//     color: $euiColorEmptyShade;

//     @include euiButtonToggleStates() {
//       background-color: darken($euiColorDarkShade, 5%);
//       border-color: darken($euiColorDarkShade, 5%);
//     }

//     &:disabled {
//       background-color: $euiButtonColorDisabled;
//       border-color: $euiButtonToggleBorderColor;
//     }
//   }
// }

